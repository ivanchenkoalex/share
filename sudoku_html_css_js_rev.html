<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Судоку</title>
  <style>
    /* --- Base layout & colors (paper look) --- */
    :root {
      --bg: #f4f1ea;
      --paper: #fffdf7;
      --ink: #1f2937;
      --muted: #6b7280;
      --accent: #0f766e;
      --grid: #cfc8b8;
      --thick: #9b927d;
      --select: #fef3c7;
      --same: #e0f2fe;
      --conflict: #fee2e2;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; color: var(--ink);
      background: linear-gradient(180deg, #ede9e0, var(--bg));
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif;
    }
    .app { max-width: 900px; margin: 0 auto; padding: 24px; display: grid; gap: 16px; }
    .card { background: var(--paper); border: 1px solid #e7dfcf; border-radius: 16px; padding: 20px; box-shadow: 0 10px 20px rgba(0,0,0,.08); }

    /* --- Screens --- */
    .screen { display: none; }
    .screen.active { display: block; }

    /* --- Header --- */
    .header { display: flex; align-items: center; justify-content: space-between; gap: 12px; flex-wrap: wrap; }
    .title { font-size: 28px; font-weight: 800; letter-spacing: .5px; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; }
    .subtle { color: var(--muted); font-size: 14px; }

    /* --- Buttons --- */
    button { appearance: none; border: 1px solid #ddd1b1; background: #fffaf2; padding: 10px 14px; border-radius: 10px; cursor: pointer; box-shadow: 0 2px 0 rgba(0,0,0,.05); font-weight: 600; color: #3f3a33; transition: transform .05s ease, box-shadow .2s ease, background .2s ease; }
    button:hover { background: #fff5e1; }
    button:active { transform: translateY(1px); box-shadow: 0 1px 0 rgba(0,0,0,.05); }
    .btn-accent { border-color: #99f6e4; background: #ecfeff; }
    .btn-danger { border-color: #fecaca; background: #fff1f2; color: #7f1d1d; }
    /* Toggle visual for Notes button */
    .toggle[aria-pressed="true"] { background: #e6fffa; border-color: #99f6e4; box-shadow: inset 0 2px 0 rgba(0,0,0,.05); }
    .toggle[aria-pressed="false"] { background: #fffaf2; }

    /* --- Board --- */
    .board-wrap { display: grid; grid-template-columns: 1fr; gap: 12px; }
    .board { width: 100%; aspect-ratio: 1/1; max-width: 640px; margin: 0 auto; position: relative; border-radius: 12px; }
    .grid { display: grid; grid-template-columns: repeat(9, 1fr); grid-template-rows: repeat(9, 1fr); width: 100%; height: 100%; border: 2px solid var(--thick); border-radius: 12px; overflow: hidden; background: var(--paper); }
    .cell { border: 1px solid var(--grid); position: relative; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: clamp(16px, 3.6vw, 28px); user-select: none; }
    /* Thick 3x3 borders */
    .cell[data-r="2"], .cell[data-r="5"] { border-bottom: 2px solid var(--thick); }
    .cell[data-c="2"], .cell[data-c="5"] { border-right: 2px solid var(--thick); }
    .cell.given { background: #fffbeb; color: #44403c; }
    .cell.active { background: var(--select); outline: 2px dashed #eab308; outline-offset: -2px; }
    .cell.same { background: var(--same); }
    .cell.conflict { background: var(--conflict); }
    .cell.locked { color: #6b7280; font-weight: 800; }

    /* Pencil notes */
    .notes { position: absolute; inset: 2px; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); font-size: clamp(8px, 1.6vw, 12px); font-weight: 600; color: #6b7280; pointer-events: none; padding: 2px; gap: 2px; text-align: center; }

    /* --- Numpad --- */
    .pad { display: grid; grid-template-columns: repeat(5, minmax(52px,1fr)); gap: 8px; justify-items: stretch; max-width: 640px; margin: 0 auto; }
    .pad button { padding: 12px 0; font-size: 16px; }
    .pad .wide { grid-column: span 2; }

    /* --- Start screen --- */
    .start { text-align: center; padding: 40px 20px; }
    .start h1 { font-size: 40px; margin: 0 0 12px; }
    .start p { color: var(--muted); margin: 0 0 24px; }

    /* --- Tips --- */
    .tip { text-align: center; color: var(--muted); font-size: 13px; }

    @media (max-width: 480px){
      .title { width: 100%; }
      .pad { grid-template-columns: repeat(3, minmax(52px,1fr)); }
      .pad .wide { grid-column: span 3; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="card header">
      <div class="title">Судоку</div>
      <div class="controls">
        <button id="btn-home" title="Стартовый экран">Домой</button>
        <button id="btn-new" class="btn-accent" title="Новая головоломка">Новая</button>
        <button id="btn-restart" title="Перезапустить текущую">Перезапуск</button>
        <button id="btn-hint" title="Подсказка (заполнит одну ячейку)">Подсказка</button>
      </div>
      <div class="subtle" id="status">—</div>
    </div>

    <!-- Start Screen -->
    <div id="screen-start" class="card screen active start">
      <h1>Классическое Судоку</h1>
      <p>Выберите сложность. Поле генерируется случайно при каждом запуске.</p>
      <div class="controls" style="justify-content:center;">
        <button data-diff="easy" class="btn-accent">Лёгкая</button>
        <button data-diff="medium" class="btn-accent">Средняя</button>
        <button data-diff="hard" class="btn-accent">Сложная</button>
      </div>
      <p class="tip" style="margin-top:18px;">Управление: цифры — ввод, стрелки — перемещение, Backspace — очистка, H — подсказка, N — заметки.</p>
    </div>

    <!-- Game Screen -->
    <div id="screen-game" class="card screen">
      <div class="board-wrap">
        <div class="board">
          <div id="grid" class="grid" role="grid" aria-label="Поле судоку"></div>
        </div>
        <div class="pad" aria-label="Цифровая панель">
          <button class="pad-num" data-n="1">1</button>
          <button class="pad-num" data-n="2">2</button>
          <button class="pad-num" data-n="3">3</button>
          <button class="pad-num" data-n="4">4</button>
          <button class="pad-num" data-n="5">5</button>
          <button class="pad-num" data-n="6">6</button>
          <button class="pad-num" data-n="7">7</button>
          <button class="pad-num" data-n="8">8</button>
          <button class="pad-num" data-n="9">9</button>
          <button id="pad-erase">Очистить</button>
          <button id="pad-notes" class="toggle" aria-pressed="false" title="Режим заметок (карандаш)">Заметки</button>
          <button id="pad-hint" class="wide">Подсказка</button>
        </div>
        <div class="tip">Цель: заполнить так, чтобы в каждой строке, столбце и блоке 3×3 были цифры 1–9 без повторов.</div>
      </div>
    </div>
  </div>

  <script>
    // ==========================
    // Sudoku core (generator, solver) — all in vanilla JS
    // ==========================

    // Random helpers
    const randInt = (n) => Math.floor(Math.random() * n);
    const shuffle = (arr) => { for (let i=arr.length-1;i>0;i--){ const j = randInt(i+1); [arr[i],arr[j]] = [arr[j],arr[i]]; } return arr; };

    // Deep copy 2D array
    const deepCopy = (b) => b.map(r => r.slice());

    // Safety check for placing a number
    function isSafe(board, r, c, n){
      for (let i=0;i<9;i++){ if (board[r][i]===n) return false; }
      for (let i=0;i<9;i++){ if (board[i][c]===n) return false; }
      const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
      for (let i=0;i<3;i++) for (let j=0;j<3;j++) if (board[br+i][bc+j]===n) return false;
      return true;
    }

    // Backtracking solver (in-place). Returns true if solved
    function solveBoard(board){
      for (let r=0;r<9;r++){
        for (let c=0;c<9;c++){
          if (board[r][c]===0){
            const nums = shuffle([1,2,3,4,5,6,7,8,9]);
            for (const n of nums){
              if (isSafe(board,r,c,n)){
                board[r][c]=n;
                if (solveBoard(board)) return true;
                board[r][c]=0;
              }
            }
            return false;
          }
        }
      }
      return true;
    }

    // Count solutions up to a limit (for uniqueness)
    function countSolutions(board, limit=2){
      let count=0;
      function dfs(){
        if (count>=limit) return;
        for (let r=0;r<9;r++){
          for (let c=0;c<9;c++){
            if (board[r][c]===0){
              for (let n=1;n<=9;n++){
                if (isSafe(board,r,c,n)){
                  board[r][c]=n; dfs(); board[r][c]=0;
                  if (count>=limit) return;
                }
              }
              return; // backtrack
            }
          }
        }
        count++;
      }
      dfs();
      return count;
    }

    // Generate a complete solved board
    function generateSolved(){
      const board = Array.from({length:9}, ()=> Array(9).fill(0));
      board[0] = shuffle([1,2,3,4,5,6,7,8,9]);
      solveBoard(board);
      return board;
    }

    // Carve a puzzle with unique solution according to difficulty
    function makePuzzle(solved, difficulty){
      const ranges = { easy:[36,40], medium:[30,34], hard:[24,28] }; // number of clues
      const [minC, maxC] = ranges[difficulty] || ranges.medium;
      const target = minC + randInt(maxC - minC + 1);
      const puzzle = deepCopy(solved);
      const cells = shuffle(Array.from({length:81}, (_,i)=>[Math.floor(i/9), i%9]));
      let clues = 81;
      for (const [r,c] of cells){
        if (clues <= target) break;
        const keep = puzzle[r][c];
        puzzle[r][c] = 0;
        const test = deepCopy(puzzle);
        if (countSolutions(test, 2) !== 1){ puzzle[r][c] = keep; } else { clues--; }
      }
      return puzzle;
    }

    // Candidates for notes (from current user board)
    function getCandidates(board, r, c){
      if (board[r][c]!==0) return [];
      const can=[]; for (let n=1;n<=9;n++){ if (isSafe(board,r,c,n)) can.push(n); }
      return can;
    }

    // ==========================
    // UI state & rendering
    // ==========================
    const gridEl = document.getElementById('grid');
    const screenStart = document.getElementById('screen-start');
    const screenGame  = document.getElementById('screen-game');
    const statusEl = document.getElementById('status');

    const btnHome = document.getElementById('btn-home');
    const btnNew = document.getElementById('btn-new');
    const btnRestart = document.getElementById('btn-restart');
    const btnHint = document.getElementById('btn-hint');

    const padHint = document.getElementById('pad-hint');
    const padErase = document.getElementById('pad-erase');
    const padNotes = document.getElementById('pad-notes');

    let current = {
      difficulty: 'medium',
      solved: null,
      puzzle: null,
      user: null,
      locked: null,
      notesMode: false,
      notes: null, // 9x9 of Sets
      sel: {r:0,c:0},
      snapshot: null
    };

    function setScreen(which){
      for (const el of document.querySelectorAll('.screen')) el.classList.remove('active');
      document.getElementById('screen-' + which).classList.add('active');
    }

    function updateStatus(msg){ statusEl.textContent = msg; }

    function buildGrid(){
      gridEl.innerHTML = '';
      for (let r=0;r<9;r++){
        for (let c=0;c<9;c++){
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.r = r; cell.dataset.c = c;
          cell.setAttribute('role','gridcell');
          cell.setAttribute('tabindex','0');
          cell.addEventListener('click', ()=> selectCell(r,c,true));
          cell.addEventListener('keydown', onCellKey);
          const notes = document.createElement('div'); notes.className = 'notes';
          cell.appendChild(notes);
          gridEl.appendChild(cell);
        }
      }
    }

    function refreshGrid(){
      const {user, locked, sel} = current;
      const sameVal = valueAt(sel.r, sel.c);
      for (const cell of gridEl.children){
        const r = Number(cell.dataset.r), c = Number(cell.dataset.c);
        const val = user[r][c];
        cell.classList.toggle('active', r===sel.r && c===sel.c);
        cell.classList.toggle('given',  locked[r][c]);
        cell.classList.toggle('locked', locked[r][c]);
        cell.classList.remove('conflict','same');

        const notesEl = cell.querySelector('.notes');
        notesEl.innerHTML = '';
        if (val !== 0){
          cell.textContent = val;
          cell.appendChild(notesEl);
        } else {
          cell.textContent = '';
          cell.appendChild(notesEl);
          const ns = current.notes[r][c];
          for (let n=1;n<=9;n++){
            const span = document.createElement('div');
            span.textContent = ns.has(n) ? n : '';
            notesEl.appendChild(span);
          }
        }

        if (val !== 0){
          if (hasConflict(r,c,val)) cell.classList.add('conflict');
          if (sameVal !== 0 && val === sameVal) cell.classList.add('same');
        }
      }
    }

    function hasConflict(r,c,val){
      for (let i=0;i<9;i++){ if (i!==c && current.user[r][i]===val) return true; }
      for (let i=0;i<9;i++){ if (i!==r && current.user[i][c]===val) return true; }
      const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
      for (let i=0;i<3;i++) for (let j=0;j<3;j++){
        const rr = br+i, cc = bc+j;
        if ((rr!==r || cc!==c) && current.user[rr][cc]===val) return true;
      }
      return false;
    }

    function valueAt(r,c){ return current.user?.[r]?.[c] ?? 0; }

    function selectCell(r,c,focus=false){
      current.sel = {r,c};
      refreshGrid();
      if (focus){
        const el = [...gridEl.children].find(x=>Number(x.dataset.r)===r && Number(x.dataset.c)===c);
        if (el) el.focus();
      }
      updateStatus(`Сложность: ${labelDiff(current.difficulty)} — Пустых: ${countEmpty(current.user)}`);
    }

    function labelDiff(d){ return d==='easy'?'Лёгкая':d==='medium'?'Средняя':'Сложная'; }

    // Keyboard handler for a cell
    function onCellKey(e){
      const r = Number(this.dataset.r), c = Number(this.dataset.c);
      if (e.key === 'ArrowUp')  { e.preventDefault(); selectCell(Math.max(0,r-1), c, true); return; }
      if (e.key === 'ArrowDown'){ e.preventDefault(); selectCell(Math.min(8,r+1), c, true); return; }
      if (e.key === 'ArrowLeft'){ e.preventDefault(); selectCell(r, Math.max(0,c-1), true); return; }
      if (e.key === 'ArrowRight'){ e.preventDefault(); selectCell(r, Math.min(8,c+1), true); return; }
      if (e.key === 'Backspace' || e.key === 'Delete'){ e.preventDefault(); setCell(r,c,0); return; }
      if (e.key >= '1' && e.key <= '9'){ e.preventDefault(); setCell(r,c, Number(e.key)); return; }
      if (e.key === '0' || e.key === ' '){ e.preventDefault(); setCell(r,c,0); return; }
      if (e.key.toLowerCase() === 'n'){ e.preventDefault(); toggleNotes(); }
      if (e.key.toLowerCase() === 'h'){ e.preventDefault(); hint(); }
    }

    function setCell(r,c,val){
      if (current.locked[r][c]) return;
      if (current.notesMode){
        if (val===0){ current.notes[r][c].clear(); }
        else {
          const s = current.notes[r][c];
          if (s.has(val)) s.delete(val); else s.add(val);
        }
      } else {
        current.user[r][c] = val;
        if (val!==0) current.notes[r][c].clear();
        if (val!==0){
          for (let i=0;i<9;i++){ current.notes[r][i].delete(val); current.notes[i][c].delete(val); }
          const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
          for (let i=0;i<3;i++) for (let j=0;j<3;j++) current.notes[br+i][bc+j].delete(val);
        }
        checkWin();
      }
      selectCell(r,c);
    }

    function countEmpty(board){ let k=0; for (let r=0;r<9;r++) for (let c=0;c<9;c++) if (board[r][c]===0) k++; return k; }

    function checkWin(){
      for (let r=0;r<9;r++) for (let c=0;c<9;c++) if (current.user[r][c]===0) return false;
      for (let r=0;r<9;r++) for (let c=0;c<9;c++) if (current.user[r][c]!==current.solved[r][c]){ updateStatus('Есть ошибки. Проверьте выделения.'); return false; }
      updateStatus('Готово! Вы решили судоку.');
      return true;
    }

    // Hint feature
    function hint(){
      for (let r=0;r<9;r++){
        for (let c=0;c<9;c++){
          if (current.user[r][c]===0){
            const cand = getCandidates(current.user, r, c);
            if (cand.length===1){ current.user[r][c]=cand[0]; current.notes[r][c].clear(); selectCell(r,c); return; }
          }
        }
      }
      let {r,c} = current.sel;
      if (current.user[r][c]!==0){
        const empties=[]; for (let i=0;i<9;i++) for (let j=0;j<9;j++) if (current.user[i][j]===0) empties.push([i,j]);
        if (empties.length===0) return; [r,c] = empties[randInt(empties.length)];
      }
      current.user[r][c] = current.solved[r][c];
      current.notes[r][c].clear();
      selectCell(r,c);
    }

    // Notes toggle (bottom button acts as a true toggle)
    function syncNotesUI(){
      if (padNotes){
        padNotes.setAttribute('aria-pressed', current.notesMode ? 'true' : 'false');
        padNotes.classList.toggle('btn-accent', current.notesMode);
      }
    }
    function toggleNotes(){
      current.notesMode = !current.notesMode;
      syncNotesUI();
      updateStatus(current.notesMode ? 'Режим заметок (карандаш) включён' : 'Режим заметок выключён');
    }

    // New game / restart
    function newGame(difficulty){
      current.difficulty = difficulty || current.difficulty || 'medium';
      updateStatus('Генерация...');
      const solved = generateSolved();
      const puzzle = makePuzzle(solved, current.difficulty);
      const user = deepCopy(puzzle);
      const locked = puzzle.map(row => row.map(v => v!==0));
      const notes = Array.from({length:9}, ()=> Array.from({length:9}, ()=> new Set()));
      current = { ...current, solved, puzzle, user, locked, notes, sel:{r:0,c:0}, snapshot:{ solved: deepCopy(solved), puzzle: deepCopy(puzzle) } };
      setScreen('game');
      buildGrid();
      syncNotesUI();
      selectCell(0,0,true);
      updateStatus(`Сложность: ${labelDiff(current.difficulty)} — Пустых: ${countEmpty(user)}`);
    }

    function restartGame(){
      if (!current.snapshot) return;
      current.solved = deepCopy(current.snapshot.solved);
      current.puzzle = deepCopy(current.snapshot.puzzle);
      current.user = deepCopy(current.snapshot.puzzle);
      current.locked = current.puzzle.map(row => row.map(v => v!==0));
      current.notes = Array.from({length:9}, ()=> Array.from({length:9}, ()=> new Set()));
      syncNotesUI();
      selectCell(0,0,true);
      updateStatus(`Перезапуск. Пустых: ${countEmpty(current.user)}`);
    }

    // Bind start difficulty buttons
    screenStart.querySelectorAll('button[data-diff]').forEach(b=> b.addEventListener('click', ()=> newGame(b.dataset.diff)));

    // Header buttons
    btnHome.addEventListener('click', ()=>{ setScreen('start'); updateStatus('—'); });
    btnNew.addEventListener('click', ()=> newGame(current.difficulty));
    btnRestart.addEventListener('click', ()=> restartGame());
    btnHint.addEventListener('click', ()=> hint());

    // Pad buttons
    document.querySelectorAll('.pad-num').forEach(b=> b.addEventListener('click', ()=>{ const n = Number(b.dataset.n); const {r,c} = current.sel; setCell(r,c,n); }));
    padErase.addEventListener('click', ()=>{ const {r,c} = current.sel; setCell(r,c,0); });
    padHint.addEventListener('click', ()=> hint());
    padNotes.addEventListener('click', ()=> toggleNotes());

    // Global shortcuts on game screen
    window.addEventListener('keydown', (e)=>{
      if (document.getElementById('screen-game').classList.contains('active')){
        if (e.key.toLowerCase()==='h'){ e.preventDefault(); hint(); }
        if (e.key.toLowerCase()==='n'){ e.preventDefault(); toggleNotes(); }
      }
    });

    // Initial grid build (empty) so layout is ready on first paint
    buildGrid();
  </script>
</body>
</html>
