<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#2e315f" />
  <title>Японский кроссворд — Canvas PWA (v3.8.2 pointer-only, RO throttle)</title>
  <!-- Single-file; comments in English only. -->
  <style>
    :root{
      /* Color palette */
      --navy:#2e315f;            /* filled cell */
      --navy-strong:#404a99;     /* outline and 5th grid */
      --grid-minor:rgba(64,74,153,.32);
      --grid-major:#5a66c2;
      --xmark:#8d96a5;           /* compact X */
      --tile:#ffffff;            /* clue tile */
      --tile-stroke:#e8edf3;
      --paper-1:#dfeef2;         /* minty background */
      --paper-2:#f4f7f9;
      --muted:#6e7686;
      --ink:#1b2130;
      --card:#ffffff;
      --border:#e2e8f0;
      --maxw:980px;
      --clue-on:#2e3546;         /* active number */
      --clue-dim:#9dadbf;        /* solved run */
      --clue-dimmer:#c9d2df;     /* fully solved line */
      --pill-bg: rgba(255,255,255,.75);
      --pill-border:#dfe6ef;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial,sans-serif;color:var(--ink);
      background:
        radial-gradient(80vw 80vh at 50% -20%, var(--paper-1), transparent 60%),
        radial-gradient(70vw 60vh at 80% 0%, #e0ecf0, transparent 55%),
        linear-gradient(180deg, var(--paper-2) 0%, #eef3f6 60%, #f7f8f9 100%);
    }

    #app{min-height:100%;display:flex;flex-direction:column}

    .topbar{display:flex;align-items:center;gap:12px;padding:10px 14px}
    .brand{font-weight:700;letter-spacing:.2px;color:var(--ink);margin:0 auto}
    .muted{color:var(--muted)}
    .spacer{flex:1}

    /* Screens */
    .screen{padding:16px;display:flex;flex-direction:column;align-items:center;gap:16px}
    #screen-start{min-height:calc(100vh - 120px);justify-content:center}
    #screen-start .paper{width:min(520px,calc(100% - 24px));text-align:center}

    .paper{background:var(--card);padding:18px;border:1px solid var(--border);max-width:var(--maxw);width:100%;border-radius:14px;box-shadow:0 6px 24px rgba(10,20,40,.06)}
    .paper h1{margin:0 0 8px 0}
    .difficulty{display:flex;gap:16px;justify-content:center;padding:10px 0 4px 0}
    .actions{display:flex;gap:8px;justify-content:center}

    .btn{appearance:none;border:1px solid var(--border);background:var(--card);padding:8px 14px;border-radius:12px;cursor:pointer;font-weight:600}
    .btn:hover{background:#fff}
    .btn.primary{background:var(--navy);color:#fff;border-color:var(--navy)}
    .btn.primary:hover{filter:brightness(1.06)}
    .btn.hidden{display:none}

    .toolbar{display:flex;gap:8px;align-items:center;background:var(--pill-bg);backdrop-filter:saturate(1.2) blur(4px);
      border:1px solid var(--pill-border);padding:8px 10px;border-radius:14px;box-shadow:0 8px 28px rgba(10,20,40,.08);max-width:var(--maxw);width:100%}
    .screen.hidden{display:none}

    /* Stats pill under toolbar */
    .stats{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:8px;max-width:var(--maxw);width:100%}
    .stat{background:var(--pill-bg);border:1px solid var(--pill-border);border-radius:12px;padding:10px 12px;display:flex;align-items:center;justify-content:space-between}
    .stat .label{color:#5b6678;font-weight:600}
    .stat .val{font-weight:800}

    #boardWrap{max-width:var(--maxw);width:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;padding:12px;gap:12px}
    canvas{background:transparent;border-radius:14px;touch-action:none}

    /* Segmented mode switch */
    .mode-switch{display:flex;align-items:center;justify-content:center}
    .mode-rail{display:flex;gap:0;background:#d4dbe6;border:1px solid #c8cfda;border-radius:999px;box-shadow:0 8px 18px rgba(10,20,40,.1) inset, 0 2px 6px rgba(10,20,40,.08);overflow:hidden}
    .seg{appearance:none;border:0;background:transparent;padding:12px 18px;cursor:pointer;display:flex;align-items:center;gap:10px;font-weight:600;color:#44506a}
    .seg svg{width:28px;height:28px;display:block}
    .seg.active{background:var(--navy);color:#fff}
    .seg.active svg{fill:#fff}
    .seg:not(.active) svg{fill:#637188}

    .toggle{display:flex;align-items:center;gap:8px;padding:4px 8px;border:1px solid var(--pill-border);border-radius:10px;background:#fff}

    @media (max-width:520px){.toolbar{flex-wrap:wrap}.stats{grid-template-columns:repeat(2,minmax(0,1fr))}}

    /* Win modal */
    .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(15,20,30,.35);backdrop-filter:blur(2px);z-index:50}
    .overlay.hidden{display:none}
    .modal{background:#fff;border:1px solid var(--pill-border);border-radius:16px;box-shadow:0 16px 48px rgba(20,30,50,.25);padding:18px;min-width:320px;width:min(520px,90vw);text-align:center}
    .modal h2{margin:6px 0 4px 0}
    .modal .stats{grid-template-columns:repeat(4,1fr);margin-top:10px}
    .modal .actions{display:flex;gap:8px;justify-content:center;margin-top:12px}
  </style>
</head>
<body>
  <div id="app">
    <header class="topbar">
      <div class="brand">Японский кроссворд</div>
      <button id="btn-install" class="btn hidden" style="margin-left:auto">Установить</button>
    </header>

    <main id="screen-start" class="screen">
      <div class="paper">
        <h1>Новая игра</h1>
        <p class="muted">Сложность:</p>
        <div class="difficulty">
          <label><input type="radio" name="difficulty" value="5" checked> 5×5</label>
          <label><input type="radio" name="difficulty" value="10"> 10×10</label>
          <label><input type="radio" name="difficulty" value="15"> 15×15</label>
        </div>
        <div class="actions">
          <button id="btn-start" class="btn primary">Старт</button>
        </div>
      </div>
      <p class="muted" style="max-width:520px;text-align:center">ЛКМ — активный режим, ПКМ — крестик. Есть подсказки и авто‑крестики.</p>
    </main>

    <main id="screen-game" class="screen hidden">
      <div class="toolbar">
        <button id="btn-back" class="btn">На старт</button>
        <button id="btn-new" class="btn">Новая</button>
        <button id="btn-restart" class="btn">Рестарт</button>
        <button id="btn-hint" class="btn">Подсказка</button>
        <label class="toggle"><input id="autoXToggle" type="checkbox" checked> Авто‑крестики</label>
        <div class="spacer"></div>
        <div class="muted">Режим: <span id="modeLabel">заливка</span></div>
      </div>

      <div class="stats" id="stats">
        <div class="stat"><span class="label">Ходы</span><span class="val" id="stat-moves">0</span></div>
        <div class="stat"><span class="label">Ошибки</span><span class="val" id="stat-errors">0</span></div>
        <div class="stat"><span class="label">Подсказки</span><span class="val" id="stat-hints">0</span></div>
        <div class="stat"><span class="label">Время</span><span class="val" id="stat-time">00:00</span></div>
      </div>

      <div id="boardWrap">
        <canvas id="boardCanvas" width="1200" height="900" aria-label="Игровое поле"></canvas>
        <div class="mode-switch" role="group" aria-label="Режим рисования">
          <div class="mode-rail" id="modeRail">
            <button id="btn-eraser" class="seg" aria-pressed="false" title="Ластик">
              <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6l12 12M18 6L6 18" stroke-width="3" stroke="currentColor" fill="none" stroke-linecap="round"/></svg>
              <span>Крестик</span>
            </button>
            <button id="btn-pencil" class="seg active" aria-pressed="true" title="Карандаш">
              <svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="8"/></svg>
              <span>Заливка</span>
            </button>
          </div>
        </div>
      </div>
    </main>
  </div>

  <div id="winOverlay" class="overlay hidden" aria-modal="true" role="dialog">
    <div class="modal">
      <h2>Поздравляем!</h2>
      <div class="muted">Уровень пройден</div>
      <div class="stats">
        <div class="stat"><span class="label">Ходы</span><span class="val" id="win-moves">0</span></div>
        <div class="stat"><span class="label">Ошибки</span><span class="val" id="win-errors">0</span></div>
        <div class="stat"><span class="label">Подсказки</span><span class="val" id="win-hints">0</span></div>
        <div class="stat"><span class="label">Время</span><span class="val" id="win-time">00:00</span></div>
      </div>
      <div class="actions">
        <button id="win-close" class="btn">Закрыть</button>
        <button id="win-new" class="btn primary">Новая</button>
        <button id="win-home" class="btn">На старт</button>
      </div>
    </div>
  </div>

  <script>
  "use strict";
  // ---------- Helpers ----------
  const qs  = (s, r=document)=>r.querySelector(s);
  const pad = (n)=>String(n).padStart(2,'0');
  const randInt = (a,b)=> (Math.random()*(b-a+1)|0)+a; // inclusive

  // ---------- App state ----------
  const app = {
    size: 5,
    solution: [],          // boolean grid
    state: [],             // 0 empty, 1 filled, -1 cross
    rowClues: [],
    colClues: [],
    rowRuns: [],
    colRuns: [],
    moves: 0,
    errors: 0,
    hints: 0,
    startTs: 0,
    timerId: null,

    dragging: false,
    dragSetTo: 0,
    lastDragKey: '',
    activeMode: 'fill',
    paintValue: 1,
    solved: false,
    autoX: true,
    // layout
    cell: 32,
    leftMargin: 100,
    topMargin: 100,
    badgeW: 0.56,
    badgeH: 0.56,
    tilePad: 6,
    // fx
    effects: [],           // [{type:'wrong', r,c, t0, dur}]
  };

  // DOM
  const screenStart = qs('#screen-start');
  const screenGame  = qs('#screen-game');
  const modeLabel   = qs('#modeLabel');
  const canvas      = qs('#boardCanvas');
  const ctx         = canvas.getContext('2d');
  const btnPencil   = qs('#btn-pencil');
  const btnEraser   = qs('#btn-eraser');
  const autoXToggle = qs('#autoXToggle');
  const statMoves   = qs('#stat-moves');
  const statErrors  = qs('#stat-errors');
  const statHints   = qs('#stat-hints');
  const statTime    = qs('#stat-time');
  const winOverlay  = qs('#winOverlay');
  const winMoves    = qs('#win-moves');
  const winErrors   = qs('#win-errors');
  const winHints    = qs('#win-hints');
  const winTime     = qs('#win-time');

  // ---------- Puzzle ----------
  const make2D = (n,m,v=0)=>Array.from({length:n},()=>Array.from({length:m},()=>v));
  const rnd = (p)=>Math.random()<p;

  function generateSolution(n){
    let g = make2D(n,n,false);
    const blobCount = n<=5 ? 1 : (n===10? randInt(2,3) : randInt(3,4));
    const baseP = n<=5?0.42:0.0;

    if(baseP>0){
      for(let r=0;r<n;r++) for(let c=0;c<n;c++) g[r][c] = rnd(baseP);
      if(g.flat().every(v=>!v)) g[Math.floor(n/2)][Math.floor(n/2)] = true;
    }

    if(n>5){
      for(let k=0;k<blobCount;k++){
        const rx = randInt(Math.floor(n*0.22), Math.floor(n*0.46));
        const ry = randInt(Math.floor(n*0.20), Math.floor(n*0.44));
        const cx = randInt(rx, n-1-rx);
        const cy = randInt(ry, n-1-ry);
        for(let r=0;r<n;r++) for(let c=0;c<n;c++){
          const dx=c-cx, dy=r-cy; if((dx*dx)/(rx*rx) + (dy*dy)/(ry*ry) <= 1) g[r][c]=true;
        }
      }
      for(let pass=0; pass<2; pass++){
        const ng = make2D(n,n,false);
        for(let r=0;r<n;r++) for(let c=0;c<n;c++){
          let cnt=0; for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++) if(dr||dc){ const rr=r+dr, cc=c+dc; if(rr>=0&&cc>=0&&rr<n&&cc<n && g[rr][cc]) cnt++; }
          if(g[r][c]) ng[r][c] = cnt>=2; else ng[r][c] = cnt>=5;
        }
        g = ng;
      }
    }

    g = enforceRunsPerLine(g, 4);
    if(g.flat().every(v=>!v)) g[Math.floor(n/2)][Math.floor(n/2)] = true;
    return g;
  }

  function runs1D(arr){ const out=[]; let len=0, start=0; for(let i=0;i<arr.length;i++){ if(arr[i]){ if(len===0) start=i; len++; } else if(len){ out.push({start,len}); len=0; } } if(len) out.push({start,len}); return out; }

  function enforceLine(arr, maxRuns){
    const n=arr.length; let a=arr.slice();
    let runs=runs1D(a);
    if(runs.length===0){
      const L = randInt(1, n);
      const st = randInt(0, n-L);
      for(let i=st;i<st+L;i++) a[i]=true;
      runs=runs1D(a);
    }
    while(runs.length>maxRuns){
      const gaps=[]; for(let i=0;i<runs.length-1;i++){ const left=runs[i]; const right=runs[i+1]; const st=left.start+left.len; const L=right.start - st; gaps.push({st,L,idx:i}); }
      gaps.sort((g1,g2)=>g1.L-g2.L);
      const g0=gaps[0]; for(let i=g0.st;i<g0.st+g0.L;i++) a[i]=true;
      runs=runs1D(a);
    }
    return a;
  }

  function transpose(g){ const n=g.length; const t=make2D(n,n,false); for(let r=0;r<n;r++) for(let c=0;c<n;c++) t[c][r]=g[r][c]; return t; }

  function enforceRunsPerLine(g, maxRuns){
    const n=g.length; let grid=g.map(row=>row.slice());
    for(let iter=0; iter<3; iter++){
      for(let r=0;r<n;r++) grid[r]=enforceLine(grid[r], maxRuns);
      grid = transpose(grid);
      for(let r=0;r<n;r++) grid[r]=enforceLine(grid[r], maxRuns);
      grid = transpose(grid);
    }
    return grid;
  }

  function calcClues(grid){
    const n = grid.length; const rowClues=[], colClues=[];
    for(let r=0;r<n;r++){
      const a=[]; let run=0; for(let c=0;c<n;c++){ if(grid[r][c]) run++; else if(run){a.push(run); run=0} } if(run) a.push(run); rowClues.push(a.length?a:[0]);
    }
    for(let c=0;c<n;c++){
      const a=[]; let run=0; for(let r=0;r<n;r++){ if(grid[r][c]) run++; else if(run){a.push(run); run=0} } if(run) a.push(run); colClues.push(a.length?a:[0]);
    }
    return {rowClues,colClues};
  }

  function calcRuns(grid){
    const n=grid.length; const rowRuns=[], colRuns=[];
    for(let r=0;r<n;r++){
      const arr=[]; let len=0, start=0; for(let c=0;c<n;c++){ if(grid[r][c]){ if(len===0) start=c; len++; } else if(len){ arr.push({start,len}); len=0; } } if(len) arr.push({start,len}); rowRuns.push(arr);
    }
    for(let c=0;c<n;c++){
      const arr=[]; let len=0, start=0; for(let r=0;r<n;r++){ if(grid[r][c]){ if(len===0) start=r; len++; } else if(len){ arr.push({start,len}); len=0; } } if(len) arr.push({start,len}); colRuns.push(arr);
    }
    return {rowRuns,colRuns};
  }

  // ---------- Layout & render ----------
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
  function isReady(){ return app.rowClues.length===app.size && app.colClues.length===app.size; }

  function computeLayout(){
    if(!isReady()) return;
    const wrap = qs('#boardWrap');
    const wrapW = Math.max(wrap?.getBoundingClientRect().width || 0, document.documentElement.clientWidth - 24, 360);
    const maxW = Math.min(wrapW-8, 980);
    const maxH = Math.max(window.innerHeight - 320, 360);
    const n = app.size;
    const mr = Math.max(...app.rowClues.map(a=>a.length));
    const mc = Math.max(...app.colClues.map(a=>a.length));
    const cellByW = Math.floor((maxW - 16) / (mr*app.badgeW + n));
    const cellByH = Math.floor((maxH - 16) / (mc*app.badgeH + n));
    const cell = clamp(Math.min(cellByW, cellByH), 18, 46);
    app.cell = cell;
    app.leftMargin = Math.ceil(mr * app.badgeW * cell) + 26;
    app.topMargin  = Math.ceil(mc * app.badgeH * cell) + 26;
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const cssW = app.leftMargin + n*cell + 16;
    const cssH = app.topMargin  + n*cell + 16;

    // Only mutate DOM if values actually change to avoid RO feedback loops
    const needCssW = canvas.style.width !== cssW + 'px';
    const needCssH = canvas.style.height !== cssH + 'px';
    const pxW = Math.floor(cssW * dpr);
    const pxH = Math.floor(cssH * dpr);
    const needBuf = canvas.width !== pxW || canvas.height !== pxH || canvas.dataset.dpr != String(dpr);

    if(needCssW) canvas.style.width  = cssW + 'px';
    if(needCssH) canvas.style.height = cssH + 'px';
    if(needBuf){
      canvas.width  = pxW;
      canvas.height = pxH;
      canvas.dataset.dpr = String(dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
  }

  function rr(x,y,w,h,r){
    const rad = Math.min(r, w/2, h/2); ctx.beginPath(); ctx.moveTo(x+rad,y);
    ctx.arcTo(x+w,y,x+w,y+h,rad); ctx.arcTo(x+w,y+h,x,y+h,rad); ctx.arcTo(x,y+h,x,y,rad); ctx.arcTo(x,y,x+w,y,rad); ctx.closePath();
  }

  function rowRunSatisfied(r, idx){ const run=app.rowRuns[r][idx]; if(!run) return false; for(let c=run.start;c<run.start+run.len;c++){ if(app.state[r][c]!==1) return false; } return true; }
  function colRunSatisfied(c, idx){ const run=app.colRuns[c][idx]; if(!run) return false; for(let r=run.start;r<run.start+run.len;r++){ if(app.state[r][c]!==1) return false; } return true; }
  function rowAllRequiredFilled(r){ const n=app.size; for(let c=0;c<n;c++){ if(app.solution[r][c] && app.state[r][c]!==1) return false; } return true; }
  function colAllRequiredFilled(c){ const n=app.size; for(let r=0;r<n;r++){ if(app.solution[r][c] && app.state[r][c]!==1) return false; } return true; }

  function draw(){
    if(!isReady()) return;
    const n = app.size, cell = app.cell, LM=app.leftMargin, TM=app.topMargin;
    const W = canvas.clientWidth, H = canvas.clientHeight;
    ctx.clearRect(0,0,W,H);

    const styles = getComputedStyle(document.documentElement);
    const COLOR_TILE = styles.getPropertyValue('--tile');
    const COLOR_TILE_STROKE = styles.getPropertyValue('--tile-stroke');
    const COLOR_NAVY = styles.getPropertyValue('--navy');
    const COLOR_NAVY_STRONG = styles.getPropertyValue('--navy-strong');
    const COLOR_GRID_MINOR = styles.getPropertyValue('--grid-minor');
    const COLOR_GRID_MAJOR = styles.getPropertyValue('--grid-major');
    const COLOR_X = styles.getPropertyValue('--xmark');
    const COLOR_CLUE_ON = styles.getPropertyValue('--clue-on');
    const COLOR_CLUE_DIM = styles.getPropertyValue('--clue-dim');
    const COLOR_CLUE_DIMMER = styles.getPropertyValue('--clue-dimmer');

    // Plate under grid
    const plateX = LM-10, plateY = TM-10, plateW = n*cell+20, plateH = n*cell+20;
    ctx.save(); ctx.fillStyle='rgba(255,255,255,.8)'; ctx.shadowColor='rgba(10,20,40,.12)'; ctx.shadowBlur=20; ctx.shadowOffsetY=8; rr(plateX,plateY,plateW,plateH,14); ctx.fill(); ctx.restore();

    // Clue tiles (top columns)
    const bw = app.badgeW*cell, bh = app.badgeH*cell, pad = app.tilePad;
    for(let c=0;c<n;c++){
      const arr = app.colClues[c]; const k=arr.length; const colSolved = colAllRequiredFilled(c);
      const tileW = Math.floor(cell*0.86); const tileH = Math.floor(k*bh + pad*2);
      const cx = LM + c*cell + cell/2; const tx = Math.round(cx - tileW/2); const ty = Math.round(TM - tileH - 8);
      ctx.save(); ctx.fillStyle= COLOR_TILE; ctx.strokeStyle= COLOR_TILE_STROKE; rr(tx,ty,tileW,tileH,10); ctx.fill(); ctx.lineWidth=1; ctx.stroke(); ctx.restore();
      ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font = Math.floor(cell*0.38)+'px system-ui, Arial';
      for(let i=0;i<k;i++){
        const x = cx; const y = ty + pad + (i+0.5)*bh;
        const satisfied = colRunSatisfied(c,i);
        ctx.fillStyle = satisfied ? (colSolved? COLOR_CLUE_DIMMER : COLOR_CLUE_DIM) : COLOR_CLUE_ON;
        ctx.fillText(String(arr[i]), x, y);
      }
    }

    // Clue tiles (left rows)
    for(let r=0;r<n;r++){
      const arr = app.rowClues[r]; const k=arr.length; const rowSolved = rowAllRequiredFilled(r);
      const tileH = Math.floor(cell*0.86); const tileW = Math.floor(k*bw + pad*2);
      const cy = TM + r*cell + cell/2; const ty = Math.round(cy - tileH/2); const tx = Math.round(LM - tileW - 8);
      ctx.save(); ctx.fillStyle= COLOR_TILE; ctx.strokeStyle= COLOR_TILE_STROKE; rr(tx,ty,tileW,tileH,10); ctx.fill(); ctx.lineWidth=1; ctx.stroke(); ctx.restore();
      ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font = Math.floor(cell*0.38)+'px system-ui, Arial';
      for(let i=0;i<k;i++){
        const x = tx + pad + (i+0.5)*bw; const y = cy;
        const satisfied = rowRunSatisfied(r,i);
        ctx.fillStyle = satisfied ? (rowSolved? COLOR_CLUE_DIMMER : COLOR_CLUE_DIM) : COLOR_CLUE_ON;
        ctx.fillText(String(arr[i]), x, y);
      }
    }

    // Grid outline
    ctx.lineWidth=2; ctx.strokeStyle= COLOR_NAVY_STRONG; ctx.strokeRect(LM, TM, n*cell, n*cell);

    // Grid lines
    for(let i=1;i<n;i++){
      ctx.beginPath(); ctx.lineWidth = (i%5===0)?1.6:1; ctx.strokeStyle = (i%5===0)? COLOR_GRID_MAJOR : COLOR_GRID_MINOR;
      ctx.moveTo(LM, TM + i*cell + .5); ctx.lineTo(LM + n*cell, TM + i*cell + .5); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(LM + i*cell + .5, TM); ctx.lineTo(LM + i*cell + .5, TM + n*cell); ctx.stroke();
    }

    // Cells content
    for(let r=0;r<n;r++){
      for(let c=0;c<n;c++){
        const x = LM + c*cell; const y = TM + r*cell; const v = app.state[r][c];
        if(v===1){ ctx.fillStyle= COLOR_NAVY; ctx.fillRect(x+1,y+1,cell-2,cell-2); }
        else if(v===-1){
          const inset = Math.floor(cell*0.30); // half-size cross
          ctx.strokeStyle= COLOR_X; ctx.lineWidth=Math.max(2.2, cell*0.08);
          ctx.beginPath(); ctx.moveTo(x+inset,y+inset); ctx.lineTo(x+cell-inset,y+cell-inset); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(x+cell-inset,y+inset); ctx.lineTo(x+inset,y+cell-inset); ctx.stroke();
          ctx.lineWidth=1;
        }
      }
    }

    // Wrong-paint effects (quick red fade)
    const now = performance.now();
    let hasActiveFx = false;
    for(const fx of app.effects){
      const t = (now - fx.t0) / fx.dur; if(t>=1) continue; hasActiveFx = true;
      if(fx.type==='wrong'){
        const x = LM + fx.c*cell, y = TM + fx.r*cell;
        const alpha = 0.35 * Math.pow(1-t, 0.6);
        ctx.fillStyle = `rgba(255,80,80,${alpha})`;
        ctx.fillRect(x+1,y+1,cell-2,cell-2);
      }
    }
    app.effects = app.effects.filter(fx => (now - fx.t0) < fx.dur);
    if(hasActiveFx) requestAnimationFrame(draw);
  }

  // ---------- Game flow ----------
  function newPuzzle(size){
    if(app.timerId){ clearInterval(app.timerId); app.timerId=null; }
    hideWinModal();
    app.size=size; app.solution=generateSolution(size); app.state=make2D(size,size,0);
    const {rowClues,colClues}=calcClues(app.solution); app.rowClues=rowClues; app.colClues=colClues;
    const runs=calcRuns(app.solution); app.rowRuns=runs.rowRuns; app.colRuns=runs.colRuns;
    app.moves=0; app.errors=0; app.hints=0; app.dragging=false; app.dragSetTo=0; app.lastDragKey=''; app.solved=false; app.effects=[];
    app.startTs = performance.now();
    app.timerId = setInterval(updateStatsTime, 1000);
    scheduleLayout(); updateStats(); setMode('fill');
  }

  function restartPuzzle(){ hideWinModal(); app.state=make2D(app.size,app.size,0); app.moves=0; app.errors=0; app.hints=0; app.dragging=false; app.dragSetTo=0; app.lastDragKey=''; app.solved=false; app.effects=[]; app.startTs=performance.now(); updateStats(); draw(); }

  function updateStats(){ statMoves.textContent=String(app.moves); statErrors.textContent=String(app.errors); statHints.textContent=String(app.hints); updateStatsTime(); }
  function updateStatsTime(){ if(!app.startTs) return; const s = Math.floor((performance.now()-app.startTs)/1000); const mm = Math.floor(s/60); const ss = s%60; statTime.textContent = `${pad(mm)}:${pad(ss)}`; }

  function cueWrong(r,c){ app.effects.push({type:'wrong', r, c, t0: performance.now(), dur: 380}); }

  function autoMarkRow(r){ if(!app.autoX) return; if(!rowAllRequiredFilled(r)) return; let ch=0; for(let c=0;c<app.size;c++){ if(!app.solution[r][c] && app.state[r][c]===0){ app.state[r][c]=-1; ch++; } } if(ch){ app.moves+=ch; }}
  function autoMarkCol(c){ if(!app.autoX) return; if(!colAllRequiredFilled(c)) return; let ch=0; for(let r=0;r<app.size;r++){ if(!app.solution[r][c] && app.state[r][c]===0){ app.state[r][c]=-1; ch++; } } if(ch){ app.moves+=ch; }}

  function setCell(r,c,target, allowToggle){
    if(app.solved) return false;
    const prev=app.state[r][c];
    if(target===1 && !app.solution[r][c]){
      if(prev!==-1){ app.state[r][c] = -1; app.moves++; app.errors++; cueWrong(r,c); autoMarkRow(r); autoMarkCol(c); checkSolved(); updateStats(); draw(); }
      return true;
    }
    let next=target; if(allowToggle && prev===target) next=0; if(prev===next) return false;
    app.state[r][c]=next; app.moves++; autoMarkRow(r); autoMarkCol(c); checkSolved(); updateStats(); draw(); return true;
  }

  function checkSolved(){
    const n=app.size; for(let r=0;r<n;r++) for(let c=0;c<n;c++){ const need=app.solution[r][c]?1:0; const have=app.state[r][c]===1?1:0; if(need!==have){app.solved=false;return} }
    if(!app.solved){ app.solved=true; onSolved(); }
  }

  function onSolved(){ if(app.timerId){ clearInterval(app.timerId); app.timerId=null; } showWinModal(); }

  function giveHint(){ if(app.solved) return; const n=app.size, arr=[]; for(let r=0;r<n;r++) for(let c=0;c<n;c++){ const sol=app.solution[r][c]?1:0; const have=app.state[r][c]===1?1:0; if(sol!==have) arr.push({r,c,sol}); } if(!arr.length) return; const p=arr[Math.random()*arr.length|0]; app.hints++; setCell(p.r,p.c,p.sol?1:-1,false); updateStats(); }

  // ---------- Mode & UI ----------
  function setMode(mode){ app.activeMode=mode; app.paintValue=(mode==='fill')?1:-1; modeLabel.textContent=(mode==='fill')?'заливка':'крестик';
    if(mode==='fill'){ btnPencil.classList.add('active'); btnPencil.setAttribute('aria-pressed','true'); btnEraser.classList.remove('active'); btnEraser.setAttribute('aria-pressed','false'); }
    else { btnEraser.classList.add('active'); btnEraser.setAttribute('aria-pressed','true'); btnPencil.classList.remove('active'); btnPencil.setAttribute('aria-pressed','false'); }
  }
  btnPencil.addEventListener('click', ()=> setMode('fill'));
  btnEraser.addEventListener('click', ()=> setMode('x'));
  autoXToggle.addEventListener('change', ()=>{ app.autoX = autoXToggle.checked; });

  // ---------- Pointer-only input ----------
  function modeFromPointer(e){ if(e.pointerType==='mouse' && e.button===2) return 'x'; return app.activeMode; }
  function canvasToCell(x,y){ const c=Math.floor((x-app.leftMargin)/app.cell); const r=Math.floor((y-app.topMargin)/app.cell); if(r<0||c<0||r>=app.size||c>=app.size) return null; return {r,c}; }

  canvas.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    const rect=canvas.getBoundingClientRect();
    const pt=canvasToCell(e.clientX-rect.left, e.clientY-rect.top); if(!pt) return;
    const mode=modeFromPointer(e);
    const cur=app.state[pt.r][pt.c];
    app.dragSetTo = (mode==='fill') ? (cur===1?0:1) : (cur===-1?0:-1);
    app.dragging=true; app.lastDragKey = `${pt.r}:${pt.c}`;
    setCell(pt.r,pt.c,app.dragSetTo,false);
    canvas.setPointerCapture(e.pointerId);
  });

  canvas.addEventListener('pointermove', (e)=>{
    if(!app.dragging) return;
    const rect=canvas.getBoundingClientRect();
    const pt=canvasToCell(e.clientX-rect.left, e.clientY-rect.top); if(!pt) return;
    const key=`${pt.r}:${pt.c}`; if(key===app.lastDragKey) return; // prevent rapid repeats
    app.lastDragKey=key;
    setCell(pt.r,pt.c,app.dragSetTo,false);
  });

  canvas.addEventListener('pointerup', (e)=>{ if(!app.dragging) return; app.dragging=false; app.lastDragKey=''; try{canvas.releasePointerCapture(e.pointerId);}catch(_){} });
  document.addEventListener('contextmenu', (e)=>{ if(e.target===canvas) e.preventDefault(); });

  // ---------- Layout scheduling to avoid ResizeObserver loops ----------
  let layoutRAF = 0;
  function scheduleLayout(){
    if(layoutRAF) return; // throttle to one per frame
    layoutRAF = requestAnimationFrame(()=>{ layoutRAF = 0; computeLayout(); draw(); });
  }

  // Recompute when boardWrap becomes visible/changes size
  const boardWrap = qs('#boardWrap');
  if('ResizeObserver' in window){
    const ro = new ResizeObserver(()=>{ if(isReady()) scheduleLayout(); });
    ro.observe(boardWrap);
  }

  window.addEventListener('resize', ()=>{ if(!isReady()) return; scheduleLayout(); });

  // ---------- UI ----------
  function showStart(){ screenStart.classList.remove('hidden'); screenGame.classList.add('hidden'); }
  function showGame(){ screenStart.classList.add('hidden'); screenGame.classList.remove('hidden'); }

  qs('#btn-start').addEventListener('click', ()=>{
    const val=+qs('input[name="difficulty"]:checked').value;
    // Show screen first so layout has real width; then generate.
    showGame();
    requestAnimationFrame(()=>{ newPuzzle(val); });
  });
  qs('#btn-back').addEventListener('click', ()=>{ showStart(); if(app.timerId){clearInterval(app.timerId); app.timerId=null;} });
  qs('#btn-new').addEventListener('click', ()=>{ newPuzzle(app.size); });
  qs('#btn-restart').addEventListener('click', ()=>{ restartPuzzle(); });
  qs('#btn-hint').addEventListener('click', ()=>{ giveHint(); });

  // ---------- Win modal helpers ----------
  function showWinModal(){ winMoves.textContent=String(app.moves); winErrors.textContent=String(app.errors); winHints.textContent=String(app.hints); winTime.textContent=statTime.textContent; winOverlay.classList.remove('hidden'); }
  function hideWinModal(){ winOverlay.classList.add('hidden'); }
  qs('#win-close').addEventListener('click', hideWinModal);
  qs('#win-new').addEventListener('click', ()=>{ hideWinModal(); newPuzzle(app.size); });
  qs('#win-home').addEventListener('click', ()=>{ hideWinModal(); showStart(); });
  winOverlay.addEventListener('click', (e)=>{ if(e.target===winOverlay) hideWinModal(); });

  // ---------- PWA bootstrap ----------
  let deferredPrompt=null;
  window.addEventListener('beforeinstallprompt', (e)=>{ e.preventDefault(); deferredPrompt=e; qs('#btn-install').classList.remove('hidden'); });
  qs('#btn-install').addEventListener('click', async ()=>{ if(!deferredPrompt) return; deferredPrompt.prompt(); await deferredPrompt.userChoice; deferredPrompt=null; qs('#btn-install').classList.add('hidden'); });

  function iconDataURL(size){ const c=document.createElement('canvas'); c.width=c.height=size; const x=c.getContext('2d'); x.fillStyle='#eaf2f6'; x.fillRect(0,0,size,size); x.strokeStyle='#2e315f'; x.lineWidth=Math.max(2,size/96); x.strokeRect(size*0.06,size*0.06,size*0.88,size*0.88); x.strokeStyle='#9aa3b2'; x.lineWidth=Math.max(1,size/192); for(let i=1;i<4;i++){ const p=size*0.12 + i*(size*0.76/4); x.beginPath(); x.moveTo(p,size*0.12); x.lineTo(p,size*0.88); x.stroke(); x.beginPath(); x.moveTo(size*0.12,p); x.lineTo(size*0.88,p); x.stroke(); } x.fillStyle='#2e315f'; const fills=[[0,1],[1,3],[2,0],[2,2],[3,1]]; fills.forEach(([r,c0])=>{const g=size*0.76/4; const x0=size*0.12+c0*g+3; const y0=size*0.12+r*g+3; x.fillRect(x0,y0,g-6,g-6);}); return c.toDataURL('image/png'); }

  async function setupPWA(){ if(!('serviceWorker' in navigator)) return; const manifest={ name:'Японский кроссворд', short_name:'Nonogram', start_url:'.', display:'standalone', background_color:'#eaf2f6', theme_color:'#2e315f', icons:[{src:iconDataURL(192),sizes:'192x192',type:'image/png'},{src:iconDataURL(512),sizes:'512x512',type:'image/png'}]}; const manBlob=new Blob([JSON.stringify(manifest)],{type:'application/manifest+json'}); const manUrl=URL.createObjectURL(manBlob); const link=document.createElement('link'); link.rel='manifest'; link.href=manUrl; document.head.appendChild(link); const swCode=`const CACHE='nonogram-onefile-v3-8-2';self.addEventListener('install',e=>{e.waitUntil((async()=>{const c=await caches.open(CACHE);try{await c.addAll(['./']);}catch(_){}})()); self.skipWaiting();});self.addEventListener('activate',e=>{e.waitUntil((async()=>{const ks=await caches.keys(); await Promise.all(ks.filter(k=>k!==CACHE).map(k=>caches.delete(k)));})()); self.clients.claim();});self.addEventListener('fetch',e=>{const req=e.request; e.respondWith((async()=>{const hit=await caches.match(req); if(hit) return hit; try{const res=await fetch(req); return res;}catch(err){const root=await caches.match('./'); return root||Response.error();}})());});`; const swUrl=URL.createObjectURL(new Blob([swCode],{type:'text/javascript'})); try{ await navigator.serviceWorker.register(swUrl,{scope:'./'});}catch(_){} }

  // ---------- Dev tests (run with ?test=1 or #test) ----------
  function runTests(){
    const log=(name,ok)=>console[ok?'log':'error'](`[TEST] ${ok?'PASS':'FAIL'}: ${name}`);
    try{
      let threw=false; try{ computeLayout(); draw(); }catch(e){ threw=true; console.error(e); }
      log('safe draw/compute before newPuzzle()', !threw);

      newPuzzle(15);
      const rowsOK = app.rowClues.every(a=>a.length>=1 && a.length<=4);
      const colsOK = app.colClues.every(a=>a.length>=1 && a.length<=4);
      log('runs 1..4 rows', rowsOK);
      log('runs 1..4 cols', colsOK);

      // Wrong fill increments counters
      let found=null; outer: for(let r=0;r<app.size;r++) for(let c=0;c<app.size;c++){ if(!app.solution[r][c]){ found={r,c}; break outer; } }
      const m0=app.moves, e0=app.errors; setCell(found.r,found.c,1,true);
      log('wrong fill increments', app.errors===e0+1 && app.moves===m0+1);

      // Auto-X vertical test
      const N=5; app.size=N; app.solution=make2D(N,N,false); app.state=make2D(N,N,0);
      app.solution[1][2]=true; app.solution[3][2]=true; // column 2 requires two cells
      const clues=calcClues(app.solution); app.rowClues=clues.rowClues; app.colClues=clues.colClues; const runs=calcRuns(app.solution); app.rowRuns=runs.rowRuns; app.colRuns=runs.colRuns;
      app.autoX=true; computeLayout();
      setCell(1,2,1,false); setCell(3,2,1,false);
      const okCol = [0,2,4].every(r=>app.state[r][2]===-1);
      log('Auto-X marks remaining in solved column', okCol);
    }catch(e){ console.error('[TEST] Fatal', e); }
  }

  function init(){ showStart(); setupPWA(); if(location.search.includes('test=1')||location.hash.includes('test')) runTests(); }
  init();
  </script>
</body>
</html>
